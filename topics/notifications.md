---
layout: topics
title: REDIS notifications
permalink: topics/notifications.html
disqusIdentifier: topics_notifications
disqusUrl: http://redis.cn/topics/notifications.html
discuzTid: 873
tranAuthor: wangqiang
---

Redis键空间通知
===

**重要：**键空间通知功能自2.8.0版本开始可用。

功能概述
---

键空间通知允许客户端订阅发布/订阅频道，以便以某种方式接收影响Redis数据集的事件。

可能接收的事件示例如下：

* 所有影响给定键的命令。
* 所有接收LPUSH操作的键。
* 所有在数据库0中到期的键。

事件使用Redis的普通发布/订阅层传递，因此实现了发布/订阅的客户端无需修改即可使用此功能。

由于Redis的发布/订阅是*fire and forget*，因此如果你的应用要求**可靠的事件通知**，目前还不能使用这个功能，也就是说，如果你的发布/订阅客户端断开连接，并在稍后重连，那么所有在客户端断开期间发送的事件将会丢失。

将来有计划允许更可靠的事件传递，但可能会在更一般的层面上解决，要么为发布/订阅本身带来可靠性，要么允许Lua脚本拦截发布/订阅的消息以执行推送等操作，就像往队列里推送事件一样。

事件类型
---

键空间通知的实现是为每一个影响Redis数据空间的操作发送两个不同类型的事件。例如，在数据库`0`中名为`mykey`的键上执行`DEL`操作，将触发两条消息的传递，完全等同于下面两个`PUBLISH`命令：


    PUBLISH __keyspace@0__:mykey del
    PUBLISH __keyevent@0__:del mykey

以上很容易看到，一个频道允许监听所有以键`mykey`为目标的所有事件，以及另一个频道允许获取有关所有`DEL`操作目标键的信息。

第一种事件，在频道中使用`keyspace`前缀的被叫做**键空间通知**，第二种，使用`keyevent`前缀的，被叫做**键事件通知**。

在以上例子中，为键`mykey`生成了一个`del`事件。
会发生什么：

* 键空间频道接收到的消息是事件的名称。
* 键事件频道接收到的消息是键的名称。

可以只启用其中一种通知，以便只传递我们感兴趣的事件子集。

配置
---

默认情况下，键空间事件通知是不启用的，因为虽然不太明智，但该功能会消耗一些CPU。可以使用redis.conf中的`notify-keyspace-events`或者使用**CONFIG SET**命令来开启通知。

将参数设置为空字符串会禁用通知。
为了开启通知功能，使用了一个非空字符串，由多个字符组成，每一个字符都有其特殊的含义，具体参见下表：

    K     键空间事件，以__keyspace@<db>__前缀发布。
    E     键事件事件，以__keyevent@<db>__前缀发布。
    g     通用命令（非类型特定），如DEL，EXPIRE，RENAME等等
    $     字符串命令
    l     列表命令
    s     集合命令
    h     哈希命令
    z     有序集合命令
    x     过期事件（每次键到期时生成的事件）
    e     被驱逐的事件（当一个键由于达到最大内存而被驱逐时产生的事件）
    A     g$lshzxe的别名，因此字符串AKE表示所有的事件。

字符串中应当至少存在`K`或者`E`，否则将不会传递事件，不管字符串中其余部分是什么。

例如，要为列表开启键空间事件，则配置参数必须设置为`Kl`，以此类推。

字符串`KEA`可以用于开启所有可能的事件。

Events generated by different commands
---

Different commands generate different kind of events according to the following list.

* `DEL` generates a `del` event for every deleted key.
* `RENAME` generates two events, a `rename_from` event for the source key, and a `rename_to` event for the destination key.
* `EXPIRE` generates an `expire` event when an expire is set to the key, or a `expired` event every time setting an expire results into the key being deleted (see `EXPIRE` documentation for more info).
* `SORT` generates a `sortstore` event when `STORE` is used to set a new key. If the resulting list is empty, and the `STORE` option is used, and there was already an existing key with that name, the result is that the key is deleted, so a `del` event is generated in this condition.
* `SET` and all its variants (`SETEX`, `SETNX`,`GETSET`) generate `set` events. However `SETEX` will also generate an `expire` events.
* `MSET` generates a separated `set` event for every key.
* `SETRANGE` generates a `setrange` event.
* `INCR`, `DECR`, `INCRBY`, `DECRBY` commands all generate `incrby` events.
* `INCRBYFLOAT` generates an `incrbyfloat` events.
* `APPEND` generates an `append` event.
* `LPUSH` and `LPUSHX` generates a single `lpush` event, even in the variadic case.
* `RPUSH` and `RPUSHX` generates a single `rpush` event, even in the variadic case.
* `RPOP` generates an `rpop` event. Additionally a `del` event is generated if the key is removed because the last element from the list was popped.
* `LPOP` generates an `lpop` event. Additionally a `del` event is generated if the key is removed because the last element from the list was popped.
* `LINSERT` generates an `linsert` event.
* `LSET` generates an `lset` event.
* `LTRIM` generates an `ltrim` event, and additionally a `del` event if the resulting list is empty and the key is removed.
* `RPOPLPUSH` and `BRPOPLPUSH` generate an `rpop` event and an `lpush` event. In both cases the order is guaranteed (the `lpush` event will always be delivered after the `rpop` event). Additionally a `del` event will be generated if the resulting list is zero length and the key is removed.
* `HSET`, `HSETNX` and `HMSET` all generate a single `hset` event.
* `HINCRBY` generates an `hincrby` event.
* `HINCRBYFLOAT` generates an `hincrbyfloat` event.
* `HDEL` generates a single `hdel` event, and an additional `del` event if the resulting hash is empty and the key is removed.
* `SADD` generates a single `sadd` event, even in the variadic case.
* `SREM` generates a single `srem` event, and an additional `del` event if the resulting set is empty and the key is removed.
* `SMOVE` generates an `srem` event for the source key, and an `sadd` event for the destination key.
* `SPOP` generates an `spop` event, and an additional `del` event if the resulting set is empty and the key is removed.
* `SINTERSTORE`, `SUNIONSTORE`, `SDIFFSTORE` generate `sinterstore`, `sunionostore`, `sdiffstore` events respectively. In the special case the resulting set is empty, and the key where the result is stored already exists, a `del` event is generated since the key is removed.
* `ZINCR` generates a `zincr` event.
* `ZADD` generates a single `zadd` event even when multiple elements are added.
* `ZREM` generates a single `zrem` event even when multiple elements are deleted. When the resulting sorted set is empty and the key is generated, an additional `del` event is generated.
* `ZREMBYSCORE` generates a single `zrembyscore` event. When the resulting sorted set is empty and the key is generated, an additional `del` event is generated.
* `ZREMBYRANK` generates a single `zrembyrank` event. When the resulting sorted set is empty and the key is generated, an additional `del` event is generated.
* `ZINTERSTORE` and `ZUNIONSTORE` respectively generate `zinterstore` and `zunionstore` events. In the special case the resulting sorted set is empty, and the key where the result is stored already exists, a `del` event is generated since the key is removed.
* Every time a key with a time to live associated is removed from the data set because it expired, an `expired` event is generated.
* Every time a key is evicted from the data set in order to free memory as a result of the `maxmemory` policy, an `evicted` event is generated.

**IMPORTANT** all the commands generate events only if the target key is really modified. For instance an `SREM` deleting a non-existing element from a Set will not actually change the value of the key, so no event will be generated.

If in doubt about how events are generated for a given command, the simplest
thing to do is to watch yourself:

    $ redis-cli config set notify-keyspace-events KEA
    $ redis-cli --csv psubscribe '__key*__:*'
    Reading messages... (press Ctrl-C to quit)
    "psubscribe","__key*__:*",1

At this point use `redis-cli` in another terminal to send commands to the
Redis server and watch the events generated:

    "pmessage","__key*__:*","__keyspace@0__:foo","set"
    "pmessage","__key*__:*","__keyevent@0__:set","foo"
    ...

Timing of expired events
---

Keys with a time to live associated are expired by Redis in two ways:

* When the key is accessed by a command and is found to be expired.
* Via a background system that looks for expired keys in background, incrementally, in order to be able to also collect keys that are never accessed.

The `expired` events are generated when a key is accessed and is found to be expired by one of the above systems, as a result there are no guarantees that the Redis server will be able to generate the `expired` event at the time the key time to live reaches the value of zero.

If no command targets the key constantly, and there are many keys with a TTL associated, there can be a significant delay between the time the key time to live drops to zero, and the time the `expired` event is generated.

Basically `expired` events **are generated when the Redis server deletes the key** and not when the time to live theoretically reaches the value of zero.
